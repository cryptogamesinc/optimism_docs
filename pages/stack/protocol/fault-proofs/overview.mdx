---
title: フォルトプルーフの概要
lang: en-US
description: フォルトプルーフシステム、その構成要素、およびそれらがOptimismエコシステムの分散化を強化するためにどのように連携するかについて学びます。
---

import Image from 'next/image'
import { Callout } from 'nextra/components'

# フォルトプルーフの概要

フォルトプルーフシステムは、フォルトプルーフプログラム(FPP)、フォルトプルーフ仮想マシン(FPVM)、および紛争ゲームプロトコルの3つの主要な構成要素で構成されています。
このシステムは、最終的に中央のフォールバックなしで安全なブリッジングを可能にするように設計されています。
フォルトプルーフシステムのモジュラー設計は、ZKプルーフを含むマルチプルーフの未来の基盤を築き、エコシステムの貢献者がシステムを保護するための代替フォルトプルーフコンポーネントを構築する機会を大幅に増加させます。

<Callout type="info">
  堅牢なフォルトプルーフシステムを構築するためのテストと支援の詳細については、[Immunefiのバグ報奨金ページ](https://immunefi.com/bounty/optimism/?ref=blog.oplabs.co)をご覧ください。
</Callout>

## システム設計とモジュラリティ

フォルトプルーフシステムは、フォルトプルーフプログラム(FPP)、フォルトプルーフ仮想マシン(FPVM)、および紛争ゲームプロトコルの3つの主要な構成要素で構成されています。
これらのコンポーネントは、ネットワーク上の悪意のある活動や不具合を挑戦し、システム内の信頼と一貫性を保持するために連携します。
OPスタックの最初のフォルトプルーフシステムの完全な技術的ウォークスルーについては、以下のビデオをご覧ください。

<iframe width="560" height="315" src="https://www.youtube.com/embed/nIN5sNc6nQM?si=TL9TcoV01PNcD8D2" title="Walkthrough: OP Stack Fault Proof System Alpha Release" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen />

OPスタックのユニークなモジュラーデザインにより、FPPとFPVMの分離が可能となり、以下を実現します：

*   将来的に複数のプルーフシステム、ユニークな紛争ゲーム、およびさまざまなFPVMの開発。
*   これらの分離されたコンポーネントの任意の組み合わせから構成されるカスタムビルトフォルトプルーフシステムーー有効性プルーフ、証明プルーフ、またはZKVMを含む。
*   複数のセキュリティメカニズムによって支えられた紛争プロトコル内の紛争ゲーム。

## フォルトプルーフプログラム

このシステムコンポーネントのデフォルトは`op-program`であり、L1の入力からL2の出力を検証するためにロールアップの状態遷移を通じて実行されるフォルトプルーフプログラムを実装します。この検証可能な出力は、その後、L1で紛争のある出力を解決することができます。
FPPは`op-node`と`op-geth`の組み合わせであるため、プロトコルのコンセンサス部分と実行部分の両方を単一のプロセスで持っています。これは、通常HTTPを介して行われるエンジンAPIの呼び出しが、代わりにop-gethコードへの直接のメソッド呼び出しとして行われることを意味します。

FPPは、同じ入力データで2回実行された場合、同じ出力だけでなく、同じプログラム実行トレースも結果として得られるように決定論的に実行できるように設計されています。これにより、紛争解決プロセスの一部としてオンチェーンVMで実行することができます。

すべてのデータは、Preimage Oracle APIを介して取得されます。プレイマージは、オンチェーンでFPVMによって提供されるか、またはJSON-RPCリクエストを介してノードから必要なデータをダウンロードできるネイティブの「ホスト」実装によって提供される可能性があります。ネイティブホスト実装も`op-program`によって提供されますが、オンチェーン実行の一部としては実行されません。基本的にop-programには2つの部分があります：このセクションでカバーされている「クライアント」フォルトプルーフプログラム部分と、必要なプレイマージをフェッチするために使用される「ホスト」部分です。

## フォルトプルーフ仮想マシン

フォルトプルーフ仮想マシン(FPVM)は、OPスタックのフォルトプルーフシステムのモジュールの1つです。
OPスタックのモジュラリティは、フォルトプルーフプログラム(FPP)をフォルトプルーフ仮想マシン(FPVM)から切り離し、両方のコンポーネントへの次世代の組み合わせと効率的な並列アップグレードを可能にします。FPVM内で実行されるFPP（クライアント側）は、L2の状態遷移を表現する部分であり、FPVMとFPPの間のインターフェースは標準化され、[specs](https://github.com/ethereum-optimism/optimism/blob/546fb2c7a5796b7fe50b0b7edc7666d3bd281d6f/specs/cannon-fault-proof-vm.md)で文書化されています。

この分離により、VMは超ミニマルに保たれます：Ethereumプロトコルの変更、例えばEVMオペコードの追加は、VMに影響を与えません。代わりに、プロトコルが変更されたとき、FPPは単にノードソフトウェアから新しい状態遷移コンポーネントをインポートして更新することができます。同じゲームコンソールで新しいバージョンのゲームをプレイするのと同様に、L1プルーフシステムは異なるプログラムを証明するために更新することができます。

FPVMは、より低レベルの命令実行を担当します。FPPはエミュレートされる必要があります。VMの要件は低く、プログラムは同期的であり、すべての入力は同じプレイマージオラクルを通じてロードされますが、これらすべてはまだオンチェーンのL1 EVMで証明されなければなりません。
これを行うために、一度に1つの命令のみが証明されます。二分法ゲームは、完全な実行トレースの証明を単一の命令の証明に絞り込むタスクを狭めます。命令の証明はFPVMごとに異なる場合がありますが、一般的にはCannonのように次のように見えます：

*   命令を実行するために、VMはスレッドコンテキストの命令サイクルに似たものをエミュレートします：命令はメモリから読み取られ、解釈され、レジスタファイルとメモリが少し変更される場合があります。
*   プレイマージオラクルをサポートし、メモリ割り当てなどの基本的なプログラムランタイムのニーズをサポートするために、実行はまた、linux syscallsのサブセットをサポートします。読み書きのsyscallsは、プレイマージオラクルとのやり取りを可能にします：プログラムはプレイマージの要求としてハッシュを書き込み、その後、一度に小さなチャンクで値を読み取ります。

[Cannon](cannon)は、すべての紛争で使用されるデフォルトのFPVMです。[MIPS](mips)は、紛争ゲームのモジュラリティのために実装できるCannonのオンチェーンスマートコントラクト実装です。

## 紛争ゲームプロトコル

紛争プロトコルでは、[DisputeGameFactory](https://github.com/ethereum-optimism/optimism/blob/6a53c7a3294edf140d552962f81c0f742bf445f9/packages/contracts-bedrock/src/dispute/DisputeGameFactory.sol#L4)を通じて異なるタイプの紛争ゲームを作成、管理、アップグレードすることができます。
これにより、集約プルーフシステムのような革新的な機能や、L2の状態以外のもの、例えばオンチェーンバイナリ検証に向けた`FaultDisputeGame`など、プロトコルを拡張する能力が開かれます。

紛争ゲームは、紛争プロトコルのコアプリミティブです。それはシンプルな状態マシンをモデル化し、その有効性が紛争される可能性のある任意の情報の32バイトのコミットメントで初期化されます。
それらには、プリミティブの実装者が定義する必要がある、このコミットメントを真または偽として解決する関数が含まれています。紛争ゲーム自体は、2つの基本的な特性に依存しています：

*   インセンティブの互換性：システムは偽の主張を罰し、真実のものに報酬を与えることで、公正な参加を保証します。
*   解決：各ゲームには、根本的な主張を確実に検証または無効にするメカニズムがあります。

標準は二分法ゲームです。これは特定のタイプの紛争ゲームであり、OPスタックの紛争プロトコルで最初に構築されたゲームです。
私たちは出力ルーツ（それぞれが単一のL2ブロックに対応）を二分法で分割し、単一のブロック`n -> n+1`状態遷移に到達するまで続けます。その後、以前に説明したように、単一ブロック状態遷移の実行トレースを二分法で分割します。これは、オフチェーンVMのランタイムを削減するための最適化です。
二分法が個々のトレース命令の状態へのコミットメントに到達した後、`FaultDisputeGame`は、一般的なVMを使用してオンチェーンで単一の命令ステップを実行します。
VMの状態遷移関数、`T`と呼ぶことにしますが、それは形式`T(s, i) -> s'`に従う限り、何でもかまいません。ここで`s` = 合意された事前状態、`i` = 状態遷移の入力、`s'` = 後状態です。

二分法ゲームでのVMジェネリックの最初の完全な実装には、`Cannon`と`op-program`によって生成された実行トレース内の単一命令を実行するためにEVMの上に単一のMIPSスレッドコンテキストが含まれます。

## 次のステップ

*   [Mips.sol](mips)を参照して、Cannonのオンチェーンスマートコントラクト実装についてもっと学びましょう。
*   [Cannon FPVM Specification](https://github.com/ethereum-optimism/optimism/blob/546fb2c7a5796b7fe50b0b7edc7666d3bd281d6f/specs/cannon-fault-proof-vm.md)で詳細をご覧ください。
